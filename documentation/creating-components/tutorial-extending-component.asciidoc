---
title: Extending Components
order: 8
layout: page
---

= Extending Components

Extending a component is an easy way of creating a new component.

Vaadin flow applications are formed of many web components. In most of the cases those
components have a client-side component and a server-side component.

The client-side component contains the HTML, CSS and JS code (Polymer). This client component defines
a set of properties that defines the behaviour of the component.

The server-side component allows modifying those properties to manage the component's behaviour from
Java (server side).

== Server Side Extension

Extending a component in flow is useful:

* When its child client-side component inherits from its parent client-side component: both shares the same properties.
* When it is necessary to modify or add some functionalities to the component in the server side.

[WARNING]
If it is planned to carry out many modifications in the component, it is more efficient
to extend the component in the client side. Using the Flow Element API excessively creates an overload.

= Example

.NumberField.java
[source,java]
----
public class NumericField extends TextField {

    private Button substractBtn;
    private TextField textField;
    private Button addBtn;

    private Double currentValue = 0d;
    private Double incrementValue = 1d;
    private Double decrementValue = -incrementValue;

    public NumericField() {
        initComonents();
    }

    public NumericField(Double currentValue, Double incrementValue, Double decrementValue) {
        this.currentValue = currentValue;
        this.incrementValue = incrementValue;
        this.decrementValue = decrementValue;

        initComonents();
    }

    private void initComonents(){
        substractBtn = new Button("-", event -> {
            setValue(currentValue + decrementValue);
        });

        textField = new TextField();

        addBtn = new Button("+", event -> {
            setValue(currentValue + incrementValue);
        });

        this.addToPrefix(substractBtn);
        this.addToSuffix(addBtn);

        updateShownValue(currentValue);
    }

    // ...
}
----

[NOTE]
It is possible to hide the parent's API on the server side using `Composite<Parent>`.

[NOTE]
`Element` API contains methods for updating and querying various parts of the element, such as attributes.
Every component has a `getElement()` function that allows to access it.
Learn more about the <<tutorial-component-many-elements#,`Element` API>>.

== Client Side Extension

Polymer also provides the possibility of extending components from existing ones.
There is a `extends` property, that can be used to extend an existing element on Polymer.

Inherit a template from another Polymer element can be done in several ways:

* Inheriting a base class template without modifying it.
* Overriding a base class template in a child class.
* Modifying a copy of a superclass template.
* Extending a base class template in a child class.
* Providing template extension points in a base class for content from a child class.

This document focuses mainly on the 3rd option: *Modifying a copy of a superclass template*.

It is important to remember when a component is extended that the properties and its methods are available on its children.

[NOTE]
By default, a child component uses its parent's template, if the child component does not provide its own template.

The parent's template can be accessed using `super.template`.

== Example

The following example is a `NumberFieldElement` that extends from `Vaadin.TextFieldElement`.

image:images/vaadin-number-field.png[vaadin-number-field]

In this example, there are mainly 3 steps:

. Children template definition
. Parent element extension e.g `class NumberFieldElement extends Vaadin.TextFieldElement`.
. Override the `static get template` with the final component DOM.

The first step is to define the children's DOM template.

[NOTE]
This structure will be accessed inside `static get template`.

.vaadin-number-field.html
[source,html]
----
<div disabled$="[[!_allowed(-1, value, min, max)]]"
     part="decrease-button"
     on-click="_decreaseValue"
     hidden$="[[!hasControls]]">
</div>

<div disabled$="[[!_allowed(1, value, min, max)]]"
     part="increase-button"
     on-click="_increaseValue"
     hidden$="[[!hasControls]]">
</div>
----

After that, it is necessary to specify elements that the child component is going to inherit from.
In this case, `NumberFieldElement` inherits from `Vaadin.TextFieldElement`, inheriting its properties and methods.

.vaadin-number-field.html
[source,html]
----
class NumberFieldElement extends Vaadin.TextFieldElement {
    static get is() {
        return 'vaadin-number-field';
    }

    static get properties() {
        return {
            hasControls: {
              type: Boolean,
              value: false,
              reflectToAttribue: true
            },
            min: {
              type: Number,
              reflectToAttribue: true,
              observer: '_minChanged'
            },
            max: {
              type: Number,
              reflectToAttribue: true,
              observer: '_maxChanged'
            },
            step: {
              reflectToAttribue: true,
              observer: '_stepChanged',
              value: 1
            }
        };
    }

    // ...
}
----

The superclass template can be overridden by defining a template getter that returns a modified template element.

.vaadin-number-field.html
[source,html]
----
static get template() {
    if (!memoizedTemplate) {
        // Clone the superclass template
        memoizedTemplate = super.template.cloneNode(true);

        // Retrieve this element's dom-module template
        const thisTemplate = Polymer.DomModule.import(this.is + '-template', 'template');
        const decreaseButton = thisTemplate.content.querySelector('[part="decrease-button"]');
        const increaseButton = thisTemplate.content.querySelector('[part="increase-button"]');
        const styles = thisTemplate.content.querySelector('style');

        // Add the buttons and styles to the text-field template
        const inputField = memoizedTemplate.content.querySelector('[part="input-field"]');
        const prefixSlot = memoizedTemplate.content.querySelector('[name="prefix"]');
        inputField.insertBefore(decreaseButton, prefixSlot);
        inputField.appendChild(increaseButton);
        memoizedTemplate.content.appendChild(styles);

        return memoizedTemplate;
    }
}
----

[WARNING]
It is recommended to clone the superclass template before modifying it.
In addition to this, the modified template should be memoized to avoid regenerate it again when the getter is called.
It can be done in the following way: `memoizedTemplate = super.template.cloneNode(true);`

[NOTE]
For more information about inheritance in Polymer consult the https://polymer-library.polymer-project.org/2.0/docs/devguide/dom-template#inherit[Polymer documentation].